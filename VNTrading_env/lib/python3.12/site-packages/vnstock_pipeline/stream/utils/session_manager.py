"""
Session Manager for Market Data Streaming

Handles reconnection and session management based on market trading hours.
"""

import asyncio
import datetime
import logging
import pytz
from typing import Optional, Dict, Any, Callable, Awaitable, List

# Assuming the trading_hours function is in vnstock.core.utils.market
# We'll import it directly for use in our package
try:
    from vnstock.core.utils.market import trading_hours
except ImportError:
    # Fallback to copy of the function if vnstock is not installed
    from vnstock_pipeline.stream.utils.market_hours import trading_hours

logger = logging.getLogger(__name__)


class SessionManager:
    """
    Manager for handling market sessions and connection lifecycle.
    
    This class is responsible for:
    1. Monitoring market trading hours
    2. Managing reconnection during session breaks
    3. Scheduling connection management around market open/close times
    """
    
    def __init__(self, 
                 market: str = "HOSE",
                 check_interval: int = 60,
                 reconnect_interval: int = 300,
                 pre_market_window: int = 30,
                 post_market_window: int = 30):
        """
        Initialize the session manager.
        
        Args:
            market (str): Market to monitor ('HOSE', 'HNX', 'UPCOM', 'Futures')
            check_interval (int): Interval in seconds to check market status
            reconnect_interval (int): Interval in seconds for reconnection during breaks
            pre_market_window (int): Minutes before market open to connect
            post_market_window (int): Minutes after market close to disconnect
        """
        self.market = market
        self.check_interval = check_interval
        self.reconnect_interval = reconnect_interval
        self.pre_market_window = pre_market_window
        self.post_market_window = post_market_window
        
        self.monitoring_task = None
        self.connect_handler = None
        self.disconnect_handler = None
        self.is_connected = False
        self.last_connect_time = None
        self.scheduled_tasks = []
        self.reconnect_event = asyncio.Event()
        
        # Session state tracking
        self.current_session_type = None
        self.data_status = None
        self.last_data_time = None

    def register_connect_handler(self, handler: Callable[[], Awaitable[None]]):
        """Register a function to be called when connection is needed."""
        self.connect_handler = handler
        
    def register_disconnect_handler(self, handler: Callable[[], Awaitable[None]]):
        """Register a function to be called when disconnection is needed."""
        self.disconnect_handler = handler
    
    async def start_monitoring(self):
        """Start monitoring market sessions and managing connections."""
        logger.info(f"Starting market session monitoring for {self.market}")
        self.reconnect_event.clear()
        
        # Schedule initial connection based on current market status
        await self._check_and_handle_session()
        
        # Start continuous monitoring task
        self.monitoring_task = asyncio.create_task(self._monitor_market_sessions())
        
        # Wait for the monitoring task to complete
        await self.monitoring_task
    
    async def stop_monitoring(self):
        """Stop monitoring market sessions."""
        logger.info("Stopping market session monitoring")
        
        # Cancel the monitoring task
        if self.monitoring_task:
            self.monitoring_task.cancel()
            try:
                await self.monitoring_task
            except asyncio.CancelledError:
                pass
            self.monitoring_task = None
        
        # Cancel any scheduled tasks
        for task in self.scheduled_tasks:
            if not task.done():
                task.cancel()
                try:
                    await task
                except asyncio.CancelledError:
                    pass
        self.scheduled_tasks = []
        
        # Disconnect if connected
        if self.is_connected and self.disconnect_handler:
            await self.disconnect_handler()
            self.is_connected = False
    
    async def trigger_reconnect(self):
        """Manually trigger a reconnection."""
        logger.info("Manual reconnection triggered")
        self.reconnect_event.set()
    
    async def _monitor_market_sessions(self):
        """Continuously monitor market sessions and manage connections."""
        try:
            while True:
                try:
                    # Check market status and handle session changes
                    await self._check_and_handle_session()
                    
                    # Wait for the next check interval or until reconnect is triggered
                    try:
                        await asyncio.wait_for(
                            self.reconnect_event.wait(),
                            timeout=self.check_interval
                        )
                        # If reconnect event was set, clear it and perform reconnection
                        self.reconnect_event.clear()
                        await self._perform_reconnection("Manual trigger")
                    except asyncio.TimeoutError:
                        # Normal timeout, continue with next check
                        pass
                        
                except Exception as e:
                    logger.error(f"Error in market session monitoring: {e}")
                    await asyncio.sleep(self.check_interval)
        
        except asyncio.CancelledError:
            logger.info("Market session monitoring cancelled")
            raise
    
    async def _check_and_handle_session(self):
        """Check current market session and handle connection state."""
        # Get current market status
        market_status = trading_hours(self.market)
        
        # Extract relevant information
        is_trading_hour = market_status["is_trading_hour"]
        trading_session = market_status["trading_session"]
        data_status = market_status["data_status"]
        current_time = market_status["time"]
        
        # Log status change if needed
        if trading_session != self.current_session_type or data_status != self.data_status:
            logger.info(f"Market session changed: {trading_session} (Data: {data_status})")
            
            # Update session tracking
            self.current_session_type = trading_session
            self.data_status = data_status
        
        # Get Vietnam time
        vietnam_tz = pytz.timezone("Asia/Ho_Chi_Minh")
        now = datetime.datetime.now(vietnam_tz)
        current_time_str = now.strftime("%H:%M")
        
        # Hard schedule reconnection at 12:59 for afternoon session
        if current_time_str == "12:59" and trading_session == "lunch_break":
            logger.info("Critical time detected: 12:59. Scheduling immediate reconnection for afternoon session.")
            
            # Force reconnection if we're connected
            if self.is_connected:
                await self._perform_reconnection("Scheduled reconnection for afternoon session")
                
                # Sleep to avoid multiple reconnections in the same minute
                await asyncio.sleep(55)
            
        # Hard schedule reconnection before morning close for any data settling
        elif current_time_str == "11:28" and trading_session == "continuous":
            logger.info("Critical time detected: 11:28. Scheduling reconnection before lunch break.")
            
            # Force reconnection to ensure fresh data
            if self.is_connected:
                await self._perform_reconnection("Scheduled reconnection before lunch break")
                
                # Sleep to avoid multiple reconnections in the same minute
                await asyncio.sleep(55)
        
        # Regular session handling logic follows...
        elif trading_session == "pre_market" and data_status == "preparing":
            # Connect before market opens
            if not self.is_connected:
                await self._perform_connection("Pre-market preparation")
                
        elif trading_session in ["continuous", "ato", "atc"] and is_trading_hour:
            # Ensure connection during active trading
            if not self.is_connected:
                await self._perform_connection("Trading session active")
                
        elif trading_session in ["post_market", "after_hours", "weekend"]:
            # Disconnect when market is closed
            if self.is_connected:
                await self._perform_disconnection("Market closed")

    async def _perform_connection(self, reason: str):
        """Perform connection with logging."""
        if not self.connect_handler:
            logger.warning("No connect handler registered")
            return
            
        logger.info(f"Connecting to market data feed: {reason}")
        try:
            await self.connect_handler()
            self.is_connected = True
            self.last_connect_time = datetime.datetime.now()
            logger.info("Connection successful")
        except Exception as e:
            logger.error(f"Connection failed: {e}")
    
    async def _perform_disconnection(self, reason: str):
        """Perform disconnection with logging."""
        if not self.disconnect_handler:
            logger.warning("No disconnect handler registered")
            return
            
        logger.info(f"Disconnecting from market data feed: {reason}")
        try:
            await self.disconnect_handler()
            self.is_connected = False
            logger.info("Disconnection successful")
        except Exception as e:
            logger.error(f"Disconnection failed: {e}")
    
    async def _perform_reconnection(self, reason: str):
        """Perform reconnection with logging."""
        logger.info(f"Reconnecting to market data feed: {reason}")
        
        # Disconnect first if connected
        if self.is_connected:
            await self._perform_disconnection("Reconnection")
        
        # Wait a short time before connecting again
        await asyncio.sleep(2)
        
        # Connect again
        await self._perform_connection("Reconnection")
    
    async def _schedule_reconnection(self, delay_seconds: float):
        """Schedule a reconnection after a delay."""
        try:
            await asyncio.sleep(delay_seconds)
            await self._perform_reconnection(f"Scheduled after {delay_seconds:.1f}s")
        except asyncio.CancelledError:
            logger.info("Scheduled reconnection cancelled")
            raise