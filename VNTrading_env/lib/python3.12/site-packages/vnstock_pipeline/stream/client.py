"""
Base WebSocket Client
====================

Provides the core WebSocket client functionality for market data streaming.
"""

import asyncio
import logging
import time
import traceback
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional

import websockets

class BaseWebSocketClient(ABC):
    """
    Base abstract WebSocket client for streaming market data.
    
    This abstract class provides the core functionality for WebSocket-based 
    market data streaming. Concrete implementations must be provided for
    specific data sources.
    """
    
    def __init__(self, uri: str, ping_interval: int = 25):
        """
        Initialize the WebSocket client.
        
        Args:
            uri (str): The WebSocket URI to connect to
            ping_interval (int): Interval in seconds to send ping messages
        """
        self.uri = uri
        self.ping_interval = ping_interval
        self.websocket = None
        self.running = False
        self.processors = []
        self.logger = logging.getLogger(self.__class__.__name__)
    
    def add_processor(self, processor):
        """
        Add a data processor to process incoming data.
        
        Args:
            processor: A DataProcessor instance to process the data
        """
        self.processors.append(processor)
    
    async def _send_ping(self):
        """Send ping messages to keep the connection alive."""
        while self.running:
            if self.websocket:
                try:
                    await self.websocket.send("2")  # ping message
                    self.logger.debug("Ping sent")
                except Exception as e:
                    self.logger.error(f"Error sending ping: {e}")
                    self.logger.error(traceback.format_exc())
            await asyncio.sleep(self.ping_interval)
    
    @abstractmethod
    async def _send_initial_messages(self) -> None:
        """
        Send initial subscription messages.
        
        This method must be implemented by concrete subclasses to handle
        source-specific subscription messages.
        """
        pass
    
    @abstractmethod
    def _parse_message(self, message: str) -> Optional[Dict[str, Any]]:
        """
        Parse received WebSocket messages.
        
        This method must be implemented by concrete subclasses to handle
        source-specific message formats.
        
        Args:
            message (str): The raw message received from the WebSocket
            
        Returns:
            Optional[Dict[str, Any]]: Parsed data or None if message should be ignored
        """
        pass
    
    async def _handle_messages(self) -> None:
        """Handle incoming WebSocket messages."""
        while self.running and self.websocket:
            try:
                message = await self.websocket.recv()
                parsed_data = self._parse_message(message)
                
                if parsed_data:
                    # Process data through all registered processors
                    for processor in self.processors:
                        try:
                            await processor.process(parsed_data)
                        except Exception as e:
                            self.logger.error(f"Error in processor {processor.__class__.__name__}: {e}")
                            self.logger.error(traceback.format_exc())
                    
            except websockets.exceptions.ConnectionClosed as e:
                self.logger.warning(f"WebSocket connection closed: {e}")
                break
            except Exception as e:
                self.logger.error(f"Error handling message: {e}")
                self.logger.error(traceback.format_exc())
                # Don't break the loop on error, try to continue
    
    async def connect(self) -> None:
        """
        Connect to the WebSocket server and start processing messages.
        
        This method establishes the WebSocket connection, sends initial
        subscription messages, and starts the message handling loop.
        """
        self.running = True
        
        try:
            self.logger.info(f"Connecting to {self.uri}...")
            self.websocket = await websockets.connect(self.uri)
            self.logger.info(f"Connected to {self.uri}")
            
            # Send initial messages
            await self._send_initial_messages()
            
            # Start ping task
            ping_task = asyncio.create_task(self._send_ping())
            
            # Handle messages
            await self._handle_messages()
            
            # Cancel ping task when done
            ping_task.cancel()
                
        except Exception as e:
            self.logger.error(f"Connection error: {e}")
            self.logger.error(traceback.format_exc())
        finally:
            self.running = False
            if self.websocket:
                await self.websocket.close()
            self.websocket = None
            self.logger.info("Disconnected")
    
    async def disconnect(self) -> None:
        """Disconnect from the WebSocket server."""
        self.running = False
        if self.websocket:
            try:
                await self.websocket.close()
                self.logger.info("Connection closed")
            except Exception as e:
                self.logger.error(f"Error closing connection: {e}")
                self.logger.error(traceback.format_exc())

    async def send_message(self, message: str) -> None:
        """
        Send a raw message to the server.
        
        Args:
            message (str): The raw message to send
        """
        if self.websocket:
            try:
                await self.websocket.send(message)
                self.logger.info(f"Sent message: {message[:50]}...")
            except Exception as e:
                self.logger.error(f"Error sending message: {e}")
                self.logger.error(traceback.format_exc())
        else:
            self.logger.error("Cannot send message: Not connected")