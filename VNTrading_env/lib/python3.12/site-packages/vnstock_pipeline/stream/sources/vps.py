"""
VPS Data Source
=============

WebSocket client implementation for the VPS market data source with session management.
"""

import json
import time
import logging
import traceback
import asyncio
from typing import Dict, Any, List, Optional, Set

from vnstock_pipeline.stream.client import BaseWebSocketClient
from vnstock_pipeline.stream.parsers import FinancialDataParser
from vnstock_pipeline.stream.utils.session_manager import SessionManager


class VPSDataParser(FinancialDataParser):
    """Parser for VPS market data with comprehensive event type support."""
    
    def parse_data(self, raw_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Parse and normalize VPS market data with support for all event types.
        
        Args:
            raw_data (Dict[str, Any]): The raw data from VPS
            
        Returns:
            Dict[str, Any]: The parsed and normalized data
        """
        # Get base fields from parent class
        result = super().parse_data(raw_data)
        
        event_type = raw_data.get("event_type", "")
        data = raw_data.get("data", {})
        
        # Process based on event type
        if event_type == "index":
            self._parse_index_data(data.get("data", {}), result)
        elif event_type == "stock":
            self._parse_stock_data(data.get("data", {}), result)
        elif event_type == "stockps":
            self._parse_stockps_data(data, result)
        elif event_type == "soddlot":
            self._parse_soddlot_data(data.get("data", {}), result)
        elif event_type == "board":
            self._parse_board_data(data.get("data", {}), result)
        elif event_type == "boardps":
            self._parse_boardps_data(data, result)
        elif event_type == "aggregatemarket":
            self._parse_aggregate_market_data(data, result)
        elif event_type == "aggregateps":
            self._parse_aggregate_ps_data(data, result)
        elif event_type == "spt":
            self._parse_spt_data(data, result)
        elif event_type == "psfsell":
            self._parse_psfsell_data(data, result)
        elif event_type == "regs":
            self._parse_regs_data(data, result)
        else:
            # Unknown event type, just include the raw data
            result.update({
                "raw_data": data
            })
            
        return result
    
    def _parse_index_data(self, index_data, result):
        """Parse index data"""
        result.update({
            "index_id": index_data.get("id"),
            "market_code": index_data.get("mc"),
            "current_index": index_data.get("cIndex"),
            "open_index": index_data.get("oIndex"),
            "change": None if not index_data.get("cIndex") or not index_data.get("oIndex") else 
                     index_data.get("cIndex") - index_data.get("oIndex"),
            "percent_change": self.calculate_percent_change(
                index_data.get("cIndex"), index_data.get("oIndex")
            ),
            "volume": index_data.get("vol"),
            "value": index_data.get("value"),
            "market_time": index_data.get("time"),
            "status": index_data.get("status"),
            "acc_vol": index_data.get("accVol")
        })
        
        # Parse other data
        if "ot" in index_data:
            try:
                ot_parts = index_data["ot"].split("|")
                if len(ot_parts) >= 6:
                    result.update({
                        "abs_change": float(ot_parts[0]) if ot_parts[0] else None,
                        "percent_change_text": ot_parts[1] if ot_parts[1] else None,
                        "value_ot": float(ot_parts[2]) if ot_parts[2] else None,
                        "advances": int(ot_parts[3]) if ot_parts[3] else None,
                        "declines": int(ot_parts[4]) if ot_parts[4] else None,
                        "unchanged": int(ot_parts[5]) if ot_parts[5] else None,
                    })
            except Exception as e:
                self.logger.warning(f"Failed to parse ot field: {e}")
        
        return result
    
    def _parse_stock_data(self, stock_data, result):
        """Parse stock data"""
        result.update({
            "symbol": stock_data.get("sym"),
            "stock_id": stock_data.get("id"),
            "last_price": stock_data.get("lastPrice"),
            "last_volume": stock_data.get("lastVol"),
            "change": stock_data.get("change"),
            "change_percent": stock_data.get("changePc"),
            "total_volume": stock_data.get("totalVol"),
            "high_price": stock_data.get("hp"),
            "low_price": stock_data.get("lp"),
            "change_flag": stock_data.get("ch"),  # i=increase, d=decrease, r=reference
            "low_flag": stock_data.get("lc"),
            "average_price": stock_data.get("ap"),
            "ceiling_actual": stock_data.get("ca"),
            "time": stock_data.get("time"),
            "session_id": stock_data.get("sID"),
            "side": stock_data.get("side"),
        })
        
        # Add open price if available
        if "openPrice" in stock_data:
            result["open_price"] = stock_data.get("openPrice")
            
        return result
    
    def _parse_stockps_data(self, data, result):
        """Parse stockps (stock price size) data"""
        stock_data = data.get("data", {})
        
        result.update({
            "symbol": stock_data.get("sym"),
            "stock_id": stock_data.get("id"),
            "last_price": stock_data.get("lastPrice"),
            "last_volume": stock_data.get("lastVol"),
            "color": stock_data.get("cl"),  # Color code for price movement
            "change": self._safe_convert(stock_data.get("change"), float),
            "change_percent": self._safe_convert(stock_data.get("changePc"), float),
            "total_volume": stock_data.get("totalVol"),
            "time": stock_data.get("time"),
            "high_price": stock_data.get("hp"),
            "change_flag": stock_data.get("ch"),
            "low_price": stock_data.get("lp"),
            "low_flag": stock_data.get("lc"),
            "average_price": stock_data.get("ap"),
            "ceiling_actual": stock_data.get("ca"),
            "time_server": stock_data.get("timeServer"),
            "session_id": stock_data.get("sID"),
            "level": stock_data.get("lv"),
            "open_price": stock_data.get("openPrice"),
            "side": stock_data.get("side"),
        })
        
        return result
    
    def _parse_soddlot_data(self, soddlot_data, result):
        """Parse soddlot data"""
        result.update({
            "symbol": soddlot_data.get("sym"),
            "stock_id": soddlot_data.get("id"),
            "ceiling_price": soddlot_data.get("c"),
            "floor_price": soddlot_data.get("f"),
            "reference_price": soddlot_data.get("r"),
            "last_price": soddlot_data.get("lastPrice"),
            "last_volume": soddlot_data.get("lastVolume"),
            "lot": soddlot_data.get("lot"),
            "market_code": soddlot_data.get("mc"),
            # Bid levels
            "bid_price_1": soddlot_data.get("bp1"),
            "bid_volume_1": soddlot_data.get("bv1"),
            "bid_price_2": soddlot_data.get("bp2"),
            "bid_volume_2": soddlot_data.get("bv2"),
            "bid_price_3": soddlot_data.get("bp3"),
            "bid_volume_3": soddlot_data.get("bv3"),
            # Ask levels
            "ask_price_1": soddlot_data.get("sp1"),
            "ask_volume_1": soddlot_data.get("sv1"),
            "ask_price_2": soddlot_data.get("sp2"),
            "ask_volume_2": soddlot_data.get("sv2"),
            "ask_price_3": soddlot_data.get("sp3"),
            "ask_volume_3": soddlot_data.get("sv3"),
        })
        
        return result
    
    def _parse_board_data(self, board_data, result):
        """Parse board data with g1, g2, g3 fields more robustly"""
        result.update({
            "symbol": board_data.get("sym"),
            "stock_id": board_data.get("id"),
            "side": board_data.get("side"),  # B=Buy, S=Sell
            "time_server": board_data.get("timeServer"),
            "volume_4": board_data.get("vol4"),  # Additional volume information
        })
        
        # Parse g1, g2, g3 fields which contain price|volume|change_flag
        for g_idx in range(1, 4):
            g_key = f"g{g_idx}"
            if g_key in board_data:
                try:
                    g_parts = board_data[g_key].split("|")
                    if len(g_parts) >= 3:
                        # Try to convert to float/int, but fall back to string if needed
                        try:
                            price = float(g_parts[0]) if g_parts[0] else None
                        except ValueError:
                            price = g_parts[0]  # Keep as string if not a valid float
                            
                        try:
                            volume = int(g_parts[1]) if g_parts[1] else None
                        except ValueError:
                            volume = g_parts[1]  # Keep as string if not a valid int
                            
                        result.update({
                            f"price_{g_idx}": price,
                            f"volume_{g_idx}": volume,
                            f"flag_{g_idx}": g_parts[2] if g_parts[2] else None,
                        })
                except Exception as e:
                    self.logger.warning(f"Failed to parse {g_key} field: {e}")
                    # Add the raw value for debugging
                    result.update({
                        f"{g_key}_raw": board_data.get(g_key)
                    })
        
        return result
    
    def _parse_boardps_data(self, data, result):
        """Parse boardps (board price size) data"""
        board_data = data.get("data", {})
        
        result.update({
            "symbol": board_data.get("sym"),
            "stock_id": board_data.get("id"),
            "side": board_data.get("side"),  # B=Buy, S=Sell
            "time_server": board_data.get("timeServer"),
            "volume_4": board_data.get("vol4"),
        })
        
        # Parse g1, g2, g3 fields which contain price|volume|change_flag
        for g_idx in range(1, 4):
            g_key = f"g{g_idx}"
            if g_key in board_data:
                try:
                    g_parts = board_data[g_key].split("|")
                    if len(g_parts) >= 3:
                        try:
                            price = float(g_parts[0]) if g_parts[0] else None
                        except ValueError:
                            price = g_parts[0]
                            
                        try:
                            volume = int(g_parts[1]) if g_parts[1] else None
                        except ValueError:
                            volume = g_parts[1]
                            
                        result.update({
                            f"price_{g_idx}": price,
                            f"volume_{g_idx}": volume,
                            f"flag_{g_idx}": g_parts[2] if g_parts[2] else None,
                        })
                except Exception as e:
                    self.logger.warning(f"Failed to parse {g_key} field: {e}")
                    result.update({
                        f"{g_key}_raw": board_data.get(g_key)
                    })
        
        return result
    
    def _parse_aggregate_market_data(self, data, result):
        """Parse aggregate market data"""
        result.update({
            "total_volume": data.get("vol"),
            "total_value": data.get("value"),
            "put_through_volume": data.get("ptVol"),
            "put_through_value": data.get("ptValue"),
            "foreign_buy_volume": data.get("fBVol"),
            "foreign_sell_volume": data.get("fSVol"),
            "foreign_buy_value": data.get("fBVal"),
            "foreign_sell_value": data.get("fSVal"),
            "advances": data.get("up"),
            "declines": data.get("down"),
            "unchanged": data.get("ref"),
            "foreign_net_volume": None if not data.get("fBVol") or not data.get("fSVol") else
                                data.get("fBVol") - data.get("fSVol"),
            "foreign_net_value": None if not data.get("fBVal") or not data.get("fSVal") else
                                data.get("fBVal") - data.get("fSVal"),
        })
        
        return result
    
    def _parse_aggregate_ps_data(self, data, result):
        """Parse aggregate price-size data"""
        result.update({
            "lot": data.get("lot"),
            "foreign_buy_volume": data.get("fBVol"),
            "foreign_sell_volume": data.get("fSVol"),
            "foreign_net_volume": None if not data.get("fBVol") or not data.get("fSVol") else
                                data.get("fBVol") - data.get("fSVol"),
            "bid_volume": data.get("bid"),
            "ask_volume": data.get("ask"),
            "open_interest": data.get("oi"),
        })
        
        return result
    
    def _parse_spt_data(self, data, result):
        """Parse spt (special transaction) data"""
        spt_data = data.get("data", {})
        
        result.update({
            "transaction_id": spt_data.get("id"),
            "transaction_type": spt_data.get("type"),
            "symbol": spt_data.get("sym"),
            "color": spt_data.get("color"),
            "price": self._safe_convert(spt_data.get("price"), float),
            "volume": self._safe_convert(spt_data.get("volume"), int),
            "value": self._safe_convert(spt_data.get("value"), float),
            "time": spt_data.get("time"),
            "market_id": spt_data.get("marketID"),
            "firm_no": spt_data.get("firmNo"),
        })
        
        return result
    
    def _parse_psfsell_data(self, data, result):
        """Parse psfsell (proprietary securities firm sell) data"""
        # This data seems to be just a single value
        value = data.get("data")
        
        result.update({
            "psf_sell_value": self._safe_convert(value, float)
        })
        
        return result
    
    def _parse_regs_data(self, data, result):
        """Parse registration response data"""
        result.update({
            "action": data.get("action"),
            "symbols": data.get("list", "").split(",") if isinstance(data.get("list"), str) else [],
        })
        
        return result
    
    def _safe_convert(self, value, convert_func):
        """Safely convert a value using the provided conversion function"""
        if value is None:
            return None
            
        try:
            return convert_func(value)
        except (ValueError, TypeError):
            return value


class VPSWebSocketClient(BaseWebSocketClient):
    """WebSocket client for VPS market data with session management."""
    
    def __init__(self, uri: str = "wss://bgdatafeed.vps.com.vn/socket.io/?EIO=3&transport=websocket", 
                 ping_interval: int = 25,
                 market: str = "HOSE",
                 enable_session_manager: bool = True,
                 session_check_interval: int = 60):
        """
        Initialize the VPS WebSocket client.
        
        Args:
            uri (str): The WebSocket URI to connect to
            ping_interval (int): Interval in seconds to send ping messages
            market (str): Market to monitor for trading sessions
            enable_session_manager (bool): Whether to enable automatic session management
            session_check_interval (int): Interval in seconds to check market status
        """
        super().__init__(uri, ping_interval)
        self.raw_messages = []
        self.data_parser = VPSDataParser()
        self.last_data_timestamp = None
        self.message_count = 0
        self.received_symbols: Set[str] = set()
        
        # Session management
        self.market = market
        self.enable_session_manager = enable_session_manager
        self.session_manager = None
        self.session_check_interval = session_check_interval
        
        # Data monitoring for freezing detection
        self.data_freeze_check_task = None
        self.data_freeze_threshold = 120  # seconds
    
    def add_raw_message(self, raw_message: str) -> None:
        """
        Add a raw message to be sent after connection.
        
        Args:
            raw_message (str): The raw message to send
        """
        self.raw_messages.append(raw_message)
        
    def clear_raw_messages(self) -> None:
        """Clear all raw messages."""
        self.raw_messages = []
    
    def subscribe_symbols(self, symbols: List[str]) -> None:
        """
        Subscribe to a list of symbols.
        
        Args:
            symbols (List[str]): List of stock symbols to subscribe to
        """
        symbols_str = ",".join(symbols)
        message = f'42["regs","{{\\"action\\":\\"join\\",\\"list\\":\\"{symbols_str}\\"}}"]'
        self.add_raw_message(message)
        self.logger.info(f"Added subscription for symbols: {symbols_str}")
    
    async def connect(self) -> None:
        """
        Connect to the WebSocket server and start processing messages.
        
        This overrides the base class method to add session management.
        """
        # Start session manager if enabled
        if self.enable_session_manager and not self.session_manager:
            self.session_manager = SessionManager(
                market=self.market,
                check_interval=self.session_check_interval
            )
            
            # Register connect/disconnect handlers
            self.session_manager.register_connect_handler(self._session_connect)
            self.session_manager.register_disconnect_handler(self._session_disconnect)
            
            # Start session monitoring in a separate task
            asyncio.create_task(self.session_manager.start_monitoring())
            
            # Return early to let session manager handle the actual connection
            return
        
        # If session manager is disabled, connect directly
        await self._session_connect()
    
    async def disconnect(self) -> None:
        """
        Disconnect from the WebSocket server.
        
        This overrides the base class method to add session management cleanup.
        """
        # Stop session manager if it's running
        if self.session_manager:
            await self.session_manager.stop_monitoring()
            self.session_manager = None
        
        # Stop data freeze detection if running
        if self.data_freeze_check_task and not self.data_freeze_check_task.done():
            self.data_freeze_check_task.cancel()
            try:
                await self.data_freeze_check_task
            except asyncio.CancelledError:
                pass
            self.data_freeze_check_task = None
        
        # Disconnect using parent method
        await self._session_disconnect()
    
    async def _session_connect(self) -> None:
        """Internal method for session-managed connection."""
        self.logger.info("Session manager initiating connection")
        
        # Reset state for new connection
        self.message_count = 0
        self.last_data_timestamp = None
        self.received_symbols.clear()
        
        # Connect using the parent class method
        await super().connect()
        
        # Start data freeze detection
        self.data_freeze_check_task = asyncio.create_task(self._monitor_data_freeze())
    
    async def _session_disconnect(self) -> None:
        """Internal method for session-managed disconnection."""
        self.logger.info("Session manager initiating disconnection")
        
        # Stop data freeze detection if running
        if self.data_freeze_check_task and not self.data_freeze_check_task.done():
            self.data_freeze_check_task.cancel()
            try:
                await self.data_freeze_check_task
            except asyncio.CancelledError:
                pass
            self.data_freeze_check_task = None
        
        # Disconnect using parent method
        await super().disconnect()
    
    async def _send_initial_messages(self) -> None:
        """Send all configured raw messages."""
        if not self.raw_messages:
            self.logger.warning("No raw messages configured. You may not receive any data.")
            return
            
        for message in self.raw_messages:
            if self.websocket:
                try:
                    await self.websocket.send(message)
                    self.logger.info(f"Sent raw message: {message[:50]}...")
                except Exception as e:
                    self.logger.error(f"Error sending raw message: {e}")
                    self.logger.error(traceback.format_exc())
    
    def _parse_message(self, message: str) -> Optional[Dict[str, Any]]:
        """
        Parse the received VPS-specific message.
        
        Args:
            message (str): The raw message received from the WebSocket
            
        Returns:
            Optional[Dict[str, Any]]: Parsed data or None if message should be ignored
        """
        try:
            # Log raw message for debugging
            self.logger.debug(f"Raw message received: {message[:100]}...")
            
            # Update data reception timestamp to detect freezes
            self.last_data_timestamp = time.time()
            self.message_count += 1
            
            # Handle different message types
            if message.startswith('42'):  # Data message
                # Extract the JSON part from something like: 42["data", {...}]
                message_content = message[2:]  # Remove the '42' prefix
                data = json.loads(message_content)
                
                if isinstance(data, list) and len(data) >= 2:
                    event_type = data[0]
                    payload = data[1]
                    
                    if isinstance(payload, str):
                        # If payload is still a string, parse it
                        try:
                            payload = json.loads(payload)
                        except json.JSONDecodeError:
                            self.logger.warning(f"Failed to parse payload as JSON: {payload[:100]}...")
                    
                    raw_data = {
                        "event_type": event_type,
                        "data": payload,
                        "timestamp": time.time()
                    }
                    
                    # Track symbols we're receiving data for
                    if isinstance(payload, dict) and 'data' in payload and isinstance(payload['data'], dict):
                        symbol = payload['data'].get('sym')
                        if symbol:
                            self.received_symbols.add(symbol)
                    
                    # Parse and normalize the data
                    return self.data_parser.parse_data(raw_data)
            elif message == '2':  # Ping response
                self.logger.debug("Received ping response")
            elif message == '3':  # Pong message
                self.logger.debug("Received pong message")
            elif message.startswith('0'):  # Connection established
                self.logger.info(f"Connection established: {message}")
            elif message.startswith('40'):  # Socket.IO connection established
                self.logger.info(f"Socket.IO connection established: {message}")
            elif message.startswith('41'):  # Socket.IO disconnected
                self.logger.warning(f"Socket.IO disconnected: {message}")
            else:
                self.logger.debug(f"Received unknown message type: {message[:50]}...")
                
            return None
        except Exception as e:
            self.logger.error(f"Error parsing message: {e}")
            self.logger.error(traceback.format_exc())
            self.logger.debug(f"Problematic message: {message[:200]}...")
            return None
    
    async def _monitor_data_freeze(self):
        """
        Monitor for data freezing conditions.
        
        This is particularly important during session transitions (e.g., lunch break).
        """
        try:
            consecutive_freeze_detections = 0
            check_interval = min(30, self.data_freeze_threshold // 4)  # Check 4 times before threshold
            
            while self.running:
                await asyncio.sleep(check_interval)
                
                # Skip check if we haven't received any data yet
                if self.last_data_timestamp is None:
                    continue
                
                current_time = time.time()
                time_since_last_data = current_time - self.last_data_timestamp
                
                # Check if we're approaching a data freeze
                if time_since_last_data > self.data_freeze_threshold:
                    consecutive_freeze_detections += 1
                    self.logger.warning(
                        f"Potential data freeze detected! No data for {time_since_last_data:.1f}s "
                        f"(Detection #{consecutive_freeze_detections})"
                    )
                    
                    # If we've detected multiple consecutive freezes, trigger reconnection
                    if consecutive_freeze_detections >= 2:
                        self.logger.warning("Multiple data freezes detected, triggering reconnection")
                        
                        # Use session manager to reconnect if available
                        if self.session_manager:
                            await self.session_manager.trigger_reconnect()
                        else:
                            # Reconnect directly
                            await self._handle_data_freeze()
                        
                        # Reset counter after reconnection attempt
                        consecutive_freeze_detections = 0
                else:
                    # Reset counter if we're receiving data normally
                    consecutive_freeze_detections = 0
                
        except asyncio.CancelledError:
            self.logger.info("Data freeze monitoring cancelled")
            raise
        except Exception as e:
            self.logger.error(f"Error in data freeze monitoring: {e}")
            self.logger.error(traceback.format_exc())
    
    async def _handle_data_freeze(self):
        """Handle a detected data freeze by reconnecting."""
        self.logger.info("Handling data freeze - reconnecting")
        
        # Disconnect
        try:
            self.running = False
            if self.websocket:
                await self.websocket.close()
                self.websocket = None
        except Exception as e:
            self.logger.error(f"Error disconnecting during freeze handling: {e}")
        
        # Wait a moment before reconnecting
        await asyncio.sleep(2)
        
        # Reconnect
        try:
            self.websocket = await websockets.connect(self.uri)
            self.running = True
            self.logger.info("Reconnected after data freeze")
            
            # Send initial messages
            await self._send_initial_messages()
            
            # Start ping task
            ping_task = asyncio.create_task(self._send_ping())
            
            # Reset data freeze detection state
            self.last_data_timestamp = time.time()
            
            # Handle messages
            await self._handle_messages()
            
            # Cancel ping task when done
            ping_task.cancel()
        except Exception as e:
            self.logger.error(f"Error reconnecting after data freeze: {e}")
            self.logger.error(traceback.format_exc())
    
    def get_connection_stats(self) -> Dict[str, Any]:
        """
        Get statistics about the current connection.
        
        Returns:
            Dict[str, Any]: Connection statistics
        """
        stats = {
            "connected": self.websocket is not None and self.running,
            "message_count": self.message_count,
            "received_symbols_count": len(self.received_symbols),
            "received_symbols": list(self.received_symbols),
        }
        
        if self.last_data_timestamp:
            stats["last_data_time"] = time.strftime(
                "%Y-%m-%d %H:%M:%S", 
                time.localtime(self.last_data_timestamp)
            )
            stats["seconds_since_last_data"] = time.time() - self.last_data_timestamp
        
        return stats